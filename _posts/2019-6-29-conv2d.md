---
layout: post
comments: true
mathjax: true
title: 3.2| Convolución en 2D(Filtrado espacial)
--- 
Anteriormente en los casos de la sección 2 de este blog, utilizabamos funciones de mapeo para mejorar el contraste, estas funciones las podemos imaginar como una _tabla de casos_ en la que en la entrada solo utilizamos __un solo pixel__ para generar una salida correspondiente. Es decir, tu llevabas tus $5 pesitos ($$f(x,y)$$) y el señor de la tienda ($$T$$) te daba un cubito de rikoPollo ($$g(x,y)$$).

En esta ocasión veremos la técnica de _convolución_, en el que a diferencia de los casos anteriores, aquí se trabaja sobre una _vecindad_ de valores. Imagina que estas con tus amigous y hacen una cooperacha para comprar una pizza (si eres de Rioverde, prueba las tiki pizza, las descubrí hoy domingo (2x1) y totally worth it), para escoger el sabor harán un consenso, en donde aquellos que hayan puesto más dinerou, serán los que tendrán _más peso_ en la toma de decisión. Pues algo así pasa con este procedimiento, en el post [anterior](https://bryanmed.github.io/Convoluci%C3%B3n/) hablamos acerca de la convolución de señales, y ya es tiempo de dar salto a las imágenes. 

En la __Figura 1__ podemos observar la manera en la que está compuesta una imagen, en donde su origen se encuentra en la esquina superior izquierda, por otro lado, encontramos el kernel el cual se hará pasar por toda la imagen, cuyos elementos serán multiplicados con los elementos correspondientes de la imagen, a fin de generar una respuesta. 

{: .center}
![imagenykernel]({{ site.baseurl }}/images/equalizacionGoals.PNG)
__Figura 1__ _asdasdasdasd_.

Aquí es importante resaltar el hecho de que normalmente los kernels, filtros o máscaras $$w$$ son definidos de tamaño _impar_, debido a que el origen de estas matrices se encuentra al _centro_, y es más sencillo realizar este procedimiento teniendo un centro "real". Tampoco es necesario que sean matrices cuadradas, y es así que para determinar el tamaño ($$m \times n$$) de los filtros, se utilizan las formulas:

* $$m = 2a + 1$$
* $$n = 2b + 1$$

las cuales generan número impares, por ejemplo, si $$a = 1$$ y $$b = 1$$ generaremos una ventanta de $$3 \times 3$$... Y ahora que tenemos todos los ingredientes, es momento de platicar formalmente la _convolución discreta de imágenes_, a continuación veremos la expresión con la cual está definida: 

 $$g[x, y] = \sum_{s = -a}^{a} \sum_{t = -b}^{b} w[s, t]f[x + s, y + t]$$

Y ahora vamos a desmenusarla un poquitín:

* $$g[x, y]$$ se refiere al resultado de la convolución en la posición $$x, y$$

A continuación nos topamos con dos sumatorias, las cuales van desde $$-a$$ hasta $$a$$, y de $$-b$$ a $$b$$, estos índices ya nos son familiares, pues indican de alguna manera el tamaño del kernel. Es así que podemos recorrer la totalidad de los elementos del filtro $$w$$, y de este mismo modo,limita la región de la imagen $$f$$ (cuya disposición $$x + s$$, $$y + t$$ harán que la posición $$x, y$$ sea el origen de esta área), obteniendo en el proceso dos matrices de mismo tamaño (una correspondiente al kernel y otra a una región de la imagen las cuales comparten el mismo tamaño). Todo lo que queda es obtener el producto de estas dos matrices y sumar sus elementos. Este proceso se muestra de mejor manera en el ejemplo práctico de la __Figura 2__.

{: .center}
![imagenykernel]({{ site.baseurl }}/images/equalizacionGoals.PNG)
__Figura 2__ _asdasdasdasd_.


En este caso realizamos la convolución en el pixel 3, 2 de la imagen $$f$$, con lo cual la salida se verá reflejada también en esta posición ($$g[3, 2]$$). Por otro lado, el tamaño del kernel $$w$$ es de 3 x 3, por lo tanto $$a = 1$$ y $$b = 1$$. Con esto podemos proceder a realizar la metodología descrita por la formula de convolución.

Al iniciar ambas sumatorias tenemos:

| Rating    | Security            | Explanation                             |
|-----------|---------------------|-----------------------------------------|
| Excellent | Very secure         | Criteria is met optimal                 |
| High      | Secure              | Criteria is met                         |
| Mid       | Insufficient secure | Criteria is met partly                  |
| Low       | Insecure            | Criteria is no met                      |
| N/A       | Not rated           | Criteria is not available or irrelevant |



Aquí atención, que nos topamos con dos sumatorias que van desde $$-a$$ hasta $$a$$, y de $$-b$$ a $$b$$, pues bueno, estos índices nos permiten recorrer todos los puntos del kernel $$w$$ y los correspondientes de la imagen. Pero vamos desmenusando un poquito más cómo se realiza este proceso.

* En cuanto 

$$a$$ y $$b$$ se refieren 

como observamos la imagen anterior, el kernel $$w$$ tiene su origen en el centro de este, por lo que al iniciar, de tal manera que:



Ahora trabajaremos en 2 dimensiones, con lo cual, los ingredientes necesarios para realizar la extensión de la convolución en el espacio bidimensioanl queda de la siguiente manera: 

* La imagen de entrada $$f[x, y]$$
* El _filtro_, _mask_, _kernel_ $$w[x, y]$$, el cual es el análogo a la respuesta al impulso ($$h[n]$$), si bien podemos escoger el tamaño de la __matriz__ como queramos, es recomendable utilizar ventanas de tamaño impar, debido a que cuentan con un centro real.

En la __Figura 3.1__ se observa la composición tanto de la imagen como del filtro. En la imagen de entrada, usualmente se considera su origen en la esquina superior izquierda. Por otro lado, el origen del kernel se encuentra en el centro de este (por eso es preferible utilizarlos de tamaño impar).

Bueno, la convolución en imágenes está definido por la formula:

{: .center}
$$g[x, y] = \sum_{s = -a}^{a} \sum_{t = -b}^{b} w[s, t]f[x + s, y + t]$$

Este proceso alinea 


Lo que nos dice esta operación es que para obtener el resultado de la convolución en el punto $$x, y$$, 

_multiplicaremos_ cada elemento del kernel con el pixel correspondiente de la imagen 
